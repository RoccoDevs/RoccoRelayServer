using System;
using System.Threading;
using System.Threading.Tasks;
using Bedrock.Framework.Protocols;
using Microsoft.AspNetCore.Connections;
using Microsoft.Extensions.Logging;
using Rocco.RelayServer.Core.Domain;
using Rocco.RelayServer.Core.Domain.Exceptions;
using Rocco.RelayServer.Core.Interfaces.Services;
using Rocco.RelayServer.Core.Server.Services;

namespace Rocco.RelayServer.Core.Server.ConnectionHandlers
{
    /// <summary>
    ///     Class SixtyNineProtocolHandler.
    ///     Implements the <see cref="ConnectionHandler" />
    /// </summary>
    /// <seealso cref="ConnectionHandler" />
    /// <autogeneratedoc />
    public class SixtyNineProtocolHandler : ConnectionHandler
    {
        private readonly ConnectionStore _connectionStore;
        private readonly ILogger _logger;
        private readonly IMessageHandler _messageHandler;
        private readonly IMessageReader<SixtyNineMessage> _messageReader;
        private readonly IMessageSender _messageSender;

        /// <summary>
        ///     Initializes a new instance of the <see cref="SixtyNineProtocolHandler" /> class.
        /// </summary>
        /// <param name="logger">The logger.</param>
        /// <param name="messageHandler">The message handler.</param>
        /// <param name="messageSender">The message sender.</param>
        /// <param name="connectionStore">The connection store.</param>
        /// <param name="messageReader">The message reader</param>
        /// <autogeneratedoc />
        public SixtyNineProtocolHandler(ILogger<SixtyNineProtocolHandler> logger, IMessageHandler messageHandler,
            IMessageSender messageSender, ConnectionStore connectionStore,
            IMessageReader<SixtyNineMessage> messageReader)
        {
            _logger = logger;
            _messageHandler = messageHandler;
            _messageSender = messageSender;
            _connectionStore = connectionStore;
            _messageReader = messageReader;
        }

        /// <summary>
        ///     on connected as an asynchronous operation.
        /// </summary>
        /// <param name="connection">The new <see cref="T:Microsoft.AspNetCore.Connections.ConnectionContext" /></param>
        /// <returns>A Task representing the asynchronous operation.</returns>
        /// <autogeneratedoc />
        public override async Task OnConnectedAsync(ConnectionContext connection)
        {
            var protocol = _messageReader;
            var reader = connection.CreateReader();
            while (!connection.ConnectionClosed.IsCancellationRequested)
                try
                {
                    var result = await reader.ReadAsync(protocol);
                    var message = result.Message;


                    var returnMessage = _messageHandler.HandleMessage(connection, message);

                    if (returnMessage == null || string.IsNullOrEmpty(returnMessage.Destination)) continue;

                    try
                    {
                        await _messageSender.TrySendAsync(returnMessage,
                            connection.ConnectionClosed);

                        continue;
                    }
                    catch (ConnectionNotFoundException e)
                    {
                        _logger.LogError("connection not found: {@Message}",e.Message);
                    }
                    catch (ArgumentNullException e)
                    {
                        _logger.LogError(
                            "Client {@ConnectionId} threw: {@Message} /n trace: {@StackTrace}",connection.ConnectionId,e.Message,e.StackTrace);
                    }
                    catch (Exception e)
                    {
                        _logger.LogError("Connection {@ConnectionId} threw: {@Message} /n trace: {@StackTrace}",connection.ConnectionId,e.Message,e.StackTrace);
                    }


                    if (result.IsCompleted) break;
                }
                catch (ConnectionResetException)
                {
                    var newSource = new CancellationTokenSource();
                    newSource.Cancel();
                    connection.ConnectionClosed = newSource.Token;
                }
                finally
                {
                    reader.Advance();
                }

            _logger.LogInformation("Disconnected: {@Connection}",connection.ConnectionId);
            _connectionStore.Remove(connection);
        }
    }
}