using System;
using System.Buffers;
using System.Buffers.Binary;
using System.IO;

namespace Rocco.RelayServer.Core.Services
{
    /// <summary>
    ///     Class PrefixBufferWriter.
    ///     Implements the <see cref="System.Buffers.IBufferWriter{System.Byte}" />
    /// </summary>
    /// <seealso cref="System.Buffers.IBufferWriter{System.Byte}" />
    /// <autogeneratedoc />
    public class PrefixBufferWriter : IBufferWriter<byte>
    {
        /// <summary>
        ///     The memory
        /// </summary>
        /// <autogeneratedoc />
        private readonly Memory<byte> _memory;

        /// <summary>
        ///     The writer
        /// </summary>
        /// <autogeneratedoc />
        private readonly IBufferWriter<byte> _writer;

        /// <summary>
        ///     The count
        /// </summary>
        /// <autogeneratedoc />
        private int _count;

        /// <summary>
        ///     Initializes a new instance of the <see cref="PrefixBufferWriter" /> class.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="lengthHint">The length hint.</param>
        /// <autogeneratedoc />
        public PrefixBufferWriter(IBufferWriter<byte> writer)
        {
            _writer = writer;
            _memory = writer.GetMemory();
        }

        /// <summary>
        ///     Notifies the <see cref="T:System.Buffers.IBufferWriter`1" /> that <paramref name="count" /> data items were written
        ///     to the output <see cref="T:System.Span`1" /> or <see cref="T:System.Memory`1" />.
        /// </summary>
        /// <param name="count">
        ///     The number of data items written to the <see cref="T:System.Span`1" /> or
        ///     <see cref="T:System.Memory`1" />.
        /// </param>
        /// <autogeneratedoc />
        public void Advance(int count)
        {
            _count += count;
        }

        /// <summary>
        ///     Returns a <see cref="T:System.Memory`1" /> to write to that is at least the requested size (specified by
        ///     <paramref name="sizeHint" />).
        /// </summary>
        /// <param name="sizeHint">
        ///     The minimum length of the returned <see cref="T:System.Memory`1" />. If 0, a non-empty buffer is
        ///     returned.
        /// </param>
        /// <returns>
        ///     A <see cref="T:System.Memory`1" /> of at least the size <paramref name="sizeHint" />. If
        ///     <paramref name="sizeHint" /> is 0, returns a non-empty buffer.
        /// </returns>
        /// <exception cref="InternalBufferOverflowException"></exception>
        /// <autogeneratedoc />
        public Memory<byte> GetMemory(int sizeHint)
        {
            var start = _count + 4;

            return _memory.Slice(start);
        }

        /// <summary>
        ///     Returns a <see cref="T:System.Span`1" /> to write to that is at least the requested size (specified by
        ///     <paramref name="sizeHint" />).
        /// </summary>
        /// <param name="sizeHint">
        ///     The minimum length of the returned <see cref="T:System.Span`1" />. If 0, a non-empty buffer is
        ///     returned.
        /// </param>
        /// <returns>
        ///     A <see cref="T:System.Span`1" /> of at least the size <paramref name="sizeHint" />. If
        ///     <paramref name="sizeHint" /> is 0, returns a non-empty buffer.
        /// </returns>
        /// <exception cref="InternalBufferOverflowException"></exception>
        /// <autogeneratedoc />
        public Span<byte> GetSpan(int sizeHint)
        {
            var start = _count + 4;

            return _memory.Span.Slice(start);
        }

        /// <summary>
        ///     Completes this instance.
        /// </summary>
        /// <autogeneratedoc />
        public void Complete()
        {
            BinaryPrimitives.WriteInt32BigEndian(_memory.Span, _count);

            _writer.Advance(_count + 4);
        }
    }
}